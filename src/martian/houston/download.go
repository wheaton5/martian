//
// Copyright (c) 2015 10X Genomics, Inc. All rights reserved.
//
// Houston AWS S3 downloader.
//

package main

import (
	"fmt"
	"io/ioutil"
	"martian/core"
	"martian/manager"
	"net/http"
	"os"
	"os/exec"
	"path"
	"regexp"
	"strings"
	"time"

	"github.com/aws/aws-sdk-go/aws"
	"github.com/aws/aws-sdk-go/service/s3"
	"github.com/aws/aws-sdk-go/service/s3/s3manager"
	"github.com/dustin/go-humanize"
)

const DOWNLOAD_MAXIMUM = 5 * 1000 * 1000 * 1000 // 5GB
const DOWNLOAD_INTERVAL = 5                     // minutes

type Download struct {
	size   uint64
	year   string
	month  string
	day    string
	user   string
	domain string
	uid    string
	fname  string
	fbase  string
	ftype  string
	fdir   string
	path   string
}

func NewDownload(filesPath string, size uint64, year string, month string, day string, user string, domain string, uid string, fname string) *Download {
	self := &Download{}
	self.size = size
	self.year = year
	self.month = month
	self.day = day
	self.user = user
	self.domain = domain
	self.uid = uid
	self.fname = fname
	self.fbase = strings.Split(path.Base(fname), ".")[0]
	self.ftype = path.Ext(fname)
	self.fdir = fmt.Sprintf("%s%s", uid, self.ftype)
	self.path = path.Join(filesPath, fmt.Sprintf("%s@%s", domain, user), fmt.Sprintf("%s-%s-%s-%s", year, month, day, uid), self.fbase)
	return self
}

type DownloadManager struct {
	bucket       string
	downloadPath string
	filesPath    string
	keyRE        *regexp.Regexp
	mailer       *manager.Mailer
}

func NewDownloadManager(bucket string, downloadPath string, filesPath string, mailer *manager.Mailer) *DownloadManager {
	self := &DownloadManager{}
	self.bucket = bucket
	self.downloadPath = downloadPath
	self.filesPath = filesPath
	self.keyRE = regexp.MustCompile("^(\\d{4})-(\\d{2})-(\\d{2})-(.*)@(.*)-([A-Z0-9]{5,6})-(.*)$")
	self.mailer = mailer
	return self
}

func (self *DownloadManager) StartDownloadLoop() {
	go func() {
		for {
			self.download()
			time.Sleep(time.Minute * time.Duration(DOWNLOAD_INTERVAL))
		}
	}()
}

func (self *DownloadManager) download() {

	// ListObjects in our bucket
	response, err := s3.New(nil).ListObjects(&s3.ListObjectsInput{
		Bucket: aws.String(self.bucket),
		Prefix: aws.String("2"),
	})
	if err == nil {
		core.LogInfo("dwnload", "ListObjects returned %d objects", len(response.Contents))
	} else {
		core.LogError(err, "dwnload", "ListObjects failed")
		return
	}

	fetchedList := []*Download{}

	// Iterate over all returned objects
	for _, object := range response.Contents {
		key := *object.Key
		size := uint64(*object.Size)

		if size > DOWNLOAD_MAXIMUM {
			core.LogInfo("dwnload", "Too large %s: %s", humanize.Bytes(size), key)
			continue
		}

		// Parse the object key string, must be in expected format generated by miramar
		subs := self.keyRE.FindStringSubmatch(key)
		if len(subs) != 8 {
			core.LogInfo("dwnload", "Failed to parse key: %s", key)
			continue
		}

		// Create download object
		d := NewDownload(self.filesPath, size, subs[1], subs[2], subs[3], subs[4], subs[5], subs[6], subs[7])

		// Skip if psPath already exists
		if _, err := os.Stat(d.path); err == nil {
			//core.LogInfo("download", "    Already in pipestance storage, skipping")
			continue
		}

		// Skip if fsPath already exists
		if _, err := os.Stat(d.path); err == nil {
			//core.LogInfo("download", "    Already in permanent storage, skipping")
			continue
		}

		core.LogInfo("dwnload", "Processing %s", key)

		// Setup the local file
		downloadedFile := path.Join(self.downloadPath, key)
		fd, err := os.Create(downloadedFile)
		if err != nil {
			core.LogError(err, "dwnload", "    Could not create file for download")
			continue
		}
		defer fd.Close()

		// Download file from S3
		if numBytes, err := s3manager.NewDownloader(nil).Download(fd,
			&s3.GetObjectInput{Bucket: &self.bucket, Key: &key}); err != nil {
			core.LogError(err, "dwnload", "    Download failed")
			continue
		} else {
			core.LogInfo("dwnload", "    Downloaded %s", humanize.Bytes(uint64(numBytes)))
		}

		// Read 512 bytes of downloaded file for MIME type detection
		if _, err = fd.Seek(0, 0); err != nil {
			core.LogError(err, "dwnload", "    Failed to seek to beginning of downloaded file")
			continue
		}
		var magic []byte
		magic = make([]byte, 512)
		if _, err = fd.Read(magic); err != nil {
			core.LogError(err, "dwnload", "    Failed to read downloaded file")
			continue
		}
		mimeType := http.DetectContentType(magic)

		// Handling of downloaded file depends on type
		var cmd *exec.Cmd
		if strings.HasPrefix(mimeType, "application/x-gzip") && strings.HasSuffix(d.fname, "debug.tgz") {
			core.LogInfo("dwnload", "    Pipestance, untaring")

			// Create pipestance folder
			if err := os.MkdirAll(d.path, 0755); err != nil {
				core.LogError(err, "dwnload", "    Could not create directory: %s", d.path)
				continue
			}

			// Untar pipestance into folder
			cmd = exec.Command("tar", "xf", downloadedFile, "-C", d.path)
			if _, err = cmd.Output(); err != nil {
				core.LogError(err, "dwnload", "    Error while untaring pipestance")
			}

			// Delete downloaded tar file
			os.Remove(downloadedFile)

			// Build HEAD symlink to pipestance folder
			files, _ := ioutil.ReadDir(d.path)
			if len(files) != 1 {
				core.LogInfo("dwnload", "    Tar file did not contain a pipestance folder")
				continue
			}
			os.Symlink(files[0].Name(), path.Join(d.path, "HEAD"))
			continue
		} else {

			if strings.HasPrefix(mimeType, "application/x-gzip") {
				core.LogInfo("dwnload", "    Tar file, untaring")
				cmd = exec.Command("tar", "xf", downloadedFile, "-C", d.path)
			} else if strings.HasPrefix(mimeType, "text/plain") {
				core.LogInfo("dwnload", "    Text file, copying")
				cmd = exec.Command("cp", downloadedFile, path.Join(d.path, d.fname))
			} else {
				core.LogInfo("dwnload", "    Unknown file, copying")
				cmd = exec.Command("cp", downloadedFile, path.Join(d.path, d.fname))
			}

			// Create permanent storage folder for this key
			if err := os.MkdirAll(d.path, 0755); err != nil {
				core.LogError(err, "dwnload", "    Could not create directory: %s", d.path)
				continue
			}

			// Execute handler command
			if _, err = cmd.Output(); err != nil {
				core.LogError(err, "dwnload", "    Error while running handler")

				// Remove the fsPath so this can be retried later
				os.RemoveAll(d.path)
				continue
			}
		}

		// Success! Remove the temporary downloaded file, and add to fetch list
		os.Remove(downloadedFile)
		fetchedList = append(fetchedList, d)
	}

	// Send out email enumerating newly downloaded files
	if len(fetchedList) > 0 {
		results := []string{}
		for i, d := range fetchedList {
			results = append(results, fmt.Sprintf("%d. %s@%s  %s  (%s)", i+1, d.user, d.domain, d.fname, humanize.Bytes(d.size)))
		}
		subj := fmt.Sprintf("%d New Customer Uploads", len(fetchedList))
		body := strings.Join(results, "\n")

		users := []string{}
		self.mailer.Sendmail(users, subj, body)
	}
}
