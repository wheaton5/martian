//
// Copyright (c) 2015 10X Genomics, Inc. All rights reserved.
//
// Houston download manager.
//

package main

import (
	"fmt"
	"io/ioutil"
	"martian/core"
	"net/http"
	"os"
	"os/exec"
	"path"
	"regexp"
	"strings"
	"time"

	"github.com/dustin/go-humanize"
)

type DownloadSource interface {
	Enumerate() []Downloadable
}

type Downloadable interface {
	Size() uint64
	Key() string
	Download(dstPath string)
}

type Download struct {
	size   uint64
	year   string
	month  string
	day    string
	user   string
	domain string
	uid    string
	fname  string
	fbase  string
	ftype  string
	fdir   string
	path   string
}

func NewDownload(filesPath string, size uint64, year string, month string,
	day string, user string, domain string, uid string, fname string) *Download {
	self := &Download{}
	self.size = size
	self.year = year
	self.month = month
	self.day = day
	self.user = user
	self.domain = domain
	self.uid = uid
	self.fname = fname
	self.fbase = strings.Split(path.Base(fname), ".")[0]
	self.ftype = path.Ext(fname)
	self.fdir = fmt.Sprintf("%s%s", uid, self.ftype)
	self.path = path.Join(filesPath, fmt.Sprintf("%s@%s", domain, user),
		fmt.Sprintf("%s-%s-%s-%s", year, month, day, uid), self.fbase)
	return self
}

type DownloadManager struct {
	sources             []DownloadSource
	downloadPath        string
	downloadIntervalMin int
	downloadMaxMB       uint64
	filesPath           string
	keyRE               *regexp.Regexp
	sman                *SubmissionManager
}

func NewDownloadManager(downloadPath string, downloadIntervalMin,
	downloadMaxMB int, filesPath string, sman *SubmissionManager) *DownloadManager {
	self := &DownloadManager{}
	self.sources = []DownloadSource{}
	self.downloadPath = downloadPath
	self.downloadIntervalMin = downloadIntervalMin
	self.downloadMaxMB = uint64(downloadMaxMB * 1000 * 1000)
	self.filesPath = filesPath
	self.sman = sman
	self.keyRE = regexp.MustCompile("^(\\d{4})-(\\d{2})-(\\d{2})-(.*)@(.*\\.[^-]+)-([A-Z0-9]+)-(.*)$")
	return self
}

func (self *DownloadManager) AddDownloadSource(source DownloadSource) {
	self.sources = append(self.sources, source)
}

func (self *DownloadManager) download() {
	// Iterate over all registered sources
	for _, source := range self.sources {

		// Iterate over all downloadables enumerated by source
		downloadables := source.Enumerate()
		for _, downloadable := range downloadables {
			size := downloadable.Size()
			key := downloadable.Key()

			// Enforce object key string formatting (as generated by miramar)
			subs := self.keyRE.FindStringSubmatch(key)
			if len(subs) != 8 {
				core.LogInfo("dwnload", "Failed to parse key: %s", key)
				continue
			}

			// Create download object
			d := NewDownload(self.filesPath, size, subs[1], subs[2], subs[3], subs[4], subs[5], subs[6], subs[7])

			// Skip if permanent path already exists
			if _, err := os.Stat(d.path); err == nil {
				//core.LogInfo("download", "    Already in permanent storage, skipping")
				continue
			}

			core.LogInfo("dwnload", "Processing %s", key)

			// Enforce max download size
			if size > self.downloadMaxMB {
				core.LogInfo("dwnload", "    Too large %s", humanize.Bytes(size))
				continue
			}

			dstPath := path.Join(self.downloadPath, key)
			downloadable.Download(dstPath)

			// Read 512 bytes of downloaded file for MIME type detection
			fd, err := os.Open(dstPath)
			if _, err = fd.Seek(0, 0); err != nil {
				core.LogError(err, "dwnload", "    Failed to seek to beginning of downloaded file")
				continue
			}
			defer fd.Close()
			var magic []byte
			magic = make([]byte, 512)
			if _, err = fd.Read(magic); err != nil {
				core.LogError(err, "dwnload", "    Failed to read downloaded file")
				continue
			}
			mimeType := http.DetectContentType(magic)

			// Handling of downloaded file depends on type
			var cmd *exec.Cmd
			if strings.HasPrefix(mimeType, "application/x-gzip") && strings.HasSuffix(d.fname, "debug.tgz") {
				core.LogInfo("dwnload", "    Pipestance, untaring")

				// Create pipestance folder
				if err := os.MkdirAll(d.path, 0777); err != nil {
					core.LogError(err, "dwnload", "    Could not create directory: %s", d.path)
					continue
				}

				// Untar pipestance into folder
				cmd = exec.Command("tar", "xf", dstPath, "-C", d.path)
				if _, err = cmd.Output(); err != nil {
					core.LogError(err, "dwnload", "    Error while untaring pipestance")
				}

				// Delete downloaded tar file
				os.Remove(dstPath)

				// Build HEAD symlink to pipestance folder
				files, _ := ioutil.ReadDir(d.path)
				if len(files) != 1 {
					core.LogInfo("dwnload", "    Tar file did not contain a pipestance folder")
					continue
				}
				os.Symlink(files[0].Name(), path.Join(d.path, "HEAD"))
			} else {

				if strings.HasPrefix(mimeType, "text/plain") {
					core.LogInfo("dwnload", "    Text file, copying")
					cmd = exec.Command("cp", dstPath, path.Join(d.path, d.fname))
				} else {
					core.LogInfo("dwnload", "    Unknown file, copying")
					cmd = exec.Command("cp", dstPath, path.Join(d.path, d.fname))
				}

				// Create permanent storage folder for this key
				if err := os.MkdirAll(d.path, 0777); err != nil {
					core.LogError(err, "dwnload", "    Could not create directory: %s", d.path)
					continue
				}

				// Execute handler command
				if _, err = cmd.Output(); err != nil {
					core.LogError(err, "dwnload", "    Error while running handler")

					// Remove the fsPath so this can be retried later
					os.RemoveAll(d.path)
					continue
				}
			}

			// Success! Remove the temporary downloaded file
			os.Remove(dstPath)
		}
	}
}

func (self *DownloadManager) StartDownloadLoop() {
	go func() {
		for {
			self.download()
			self.sman.InventorySubmissions()
			time.Sleep(time.Minute * time.Duration(self.downloadIntervalMin))
		}
	}()
}
